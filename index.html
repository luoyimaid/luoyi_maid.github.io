<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>welcome to luoyi&#39;s secret garden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="description" content="越努力，越幸运">
<meta property="og:type" content="website">
<meta property="og:title" content="welcome to luoyi&#39;s secret garden">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="welcome to luoyi&#39;s secret garden">
<meta property="og:description" content="越努力，越幸运">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="少年梦江南">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="welcome to luoyi&#39;s secret garden" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/default-avatar.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/highlight.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="fullpage" class="mobile-nav-left">
    
      <div id="wrapper" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-left">
      
        <a class="nav-item" href="/" title
        
        >首页</a>
      
        <a class="nav-item" href="/archives" title
        
        >归档</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-left">
        <section id="main">
  
    <article id="post-处理文本中的超链" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E8%B6%85%E9%93%BE/">处理文本中的超链</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/19/%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E8%B6%85%E9%93%BE/" class="article-date">
  <time datetime="2020-04-19T11:32:23.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%81%87%E5%88%B0%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/" rel="tag">遇到的实际问题</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>最近做需求遇到了一个问题，文本中有某几个字是超链，需要有点击跳转的操作。是比较常见也比较简单的问题，但是之前没有遇到过，这次遇到了就记录啦</p>
<h4 id="1-后端返回的数据"><a href="#1-后端返回的数据" class="headerlink" title="1. 后端返回的数据"></a>1. 后端返回的数据</h4><ul>
<li>后端返回的文本数据应该是带标签的，并且有超链的文字必须用span标签包起来，然后前端通过span标签的各个属性去处理超链文本</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">    &quot;data&quot;:&quot;&lt;div class&#x3D;&#39;purchase-notes&#39;&gt;1. 购买须知&lt;br &#x2F;&gt;2. 购买须知&lt;br &#x2F;&gt;3. 购买须知&lt;span class&#x3D;\&quot;bjh-a\&quot; data-bjh-type&#x3D;\&quot;link\&quot; data-bjh-src&#x3D;\&quot;https:\&#x2F;\&#x2F;baike.baidu.com\&#x2F;item\&#x2F;%E5%AE%8B%E7%BE%8E%E9%BE%84\&quot;&gt;\u5b8b\u7f8e\u9f84&lt;&#x2F;div&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-处理带有超链文本"><a href="#2-处理带有超链文本" class="headerlink" title="2. 处理带有超链文本"></a>2. 处理带有超链文本</h4><ul>
<li>如果有超链的文本，通过span标签分割提取出来span标签，替换class（为什么要替换class？因为我们为了方便解析，后端返回的带有超链的文本，class统一为bjh-a）</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文字中特殊的词汇处理</span><br><span class="line">&#x2F;&#x2F; 本次需求只有超链，但兼容搜索词，后续可继续丰富</span><br><span class="line">linkText(str) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果有特殊词汇(搜索词&amp;超链)</span><br><span class="line">    if (&#x2F;data-bjh-type&#x2F;.test(str)) &#123;</span><br><span class="line">        let strArray &#x3D; str.split(&#39;&lt;&#x2F;span&gt;&#39;);</span><br><span class="line">        let strArrayNew &#x3D; [];</span><br><span class="line">        strArray.forEach(function (item) &#123;</span><br><span class="line">            if (item !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">                if (&#x2F;data-bjh-type&#x3D;&quot;search&quot;&#x2F;.test(item)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 搜索词</span><br><span class="line">                    item &#x3D; item.replace(&#x2F;class&#x3D;&quot;bjh-a&quot;&#x2F;, &#39;class&#x3D;&quot;searchWord&quot;&#39;);</span><br><span class="line">                &#125; else if (&#x2F;data-bjh-type&#x3D;&quot;link&quot;&#x2F;.test(item)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 超链</span><br><span class="line">                    item &#x3D; item.replace(&#x2F;class&#x3D;&quot;bjh-a&quot;&#x2F;, &#39;class&#x3D;&quot;superLink&quot;&#39;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            strArrayNew.push(item);</span><br><span class="line">        &#125;);</span><br><span class="line">        str &#x3D; strArrayNew.join(&#39;&lt;&#x2F;span&gt;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-文本处理"><a href="#3-文本处理" class="headerlink" title="3. 文本处理"></a>3. 文本处理</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正文的文字模块</span><br><span class="line">textResolver(element, index) &#123;</span><br><span class="line">    let textClick &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">        this.props.dispatch</span><br><span class="line">        &amp;&amp; this.props.dispatch(&#39;textClick&#39;, &#123;</span><br><span class="line">            e,</span><br><span class="line">            index</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    element.data &#x3D; this.linkText(element.data);</span><br><span class="line">    return &lt;p onClick&#x3D;&#123;textClick&#125;</span><br><span class="line">        className&#x3D;&#123;classnames([</span><br><span class="line">            styles.contentText,</span><br><span class="line">            styles.contentSize,</span><br><span class="line">            CSSlib.common.contentPadding</span><br><span class="line">        ])&#125;</span><br><span class="line">        dangerouslySetInnerHTML&#x3D;&#123;&#123;__html: element.data&#125;&#125;</span><br><span class="line">    &#x2F;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-超链点击事件处理"><a href="#4-超链点击事件处理" class="headerlink" title="4. 超链点击事件处理"></a>4. 超链点击事件处理</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let clickDom &#x3D; data.e.target;</span><br><span class="line">let url &#x3D; clickDom.getAttribute(&#39;data-bjh-src&#39;);</span><br><span class="line">location.href &#x3D; url;</span><br></pre></td></tr></table></figure></div>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-react生命周期" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/19/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">react生命周期</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/19/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2020-04-19T11:24:23.000Z" itemprop="datePublished">2020-04-19</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react%E7%9B%B8%E5%85%B3/" rel="tag">react相关</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h4 id="⭐react生命周期图解"><a href="#⭐react生命周期图解" class="headerlink" title="⭐react生命周期图解"></a>⭐react生命周期图解</h4><p><img src="https://b.bdstatic.com/searchbox/icms/searchbox/img/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="react生命周期图解"></p>
<h4 id="⭐react生命周期分有三个大的阶段"><a href="#⭐react生命周期分有三个大的阶段" class="headerlink" title="⭐react生命周期分有三个大的阶段"></a>⭐react生命周期分有三个大的阶段</h4><pre><code>由于getDefaultProps是通过构造函数进行管理的，所以不在声明周期的三个阶段内，所以只会执行一次</code></pre><p><img src="https://b.bdstatic.com/searchbox/icms/searchbox/img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="生命周期的三个大阶段"></p>
<ol>
<li>mounting阶段：负责管理生命周期中的getInitialState, componentWillMount, render, componentDidMount</li>
<li>recieve_props阶段：负责管理生命周期中的componentWillRecieveProps, shouldComponentUpdate, componentWillUpdate, render, compoenntDidUpdate</li>
<li>unmounting阶段：负责管理生命周期中的componentWillUnmount</li>
</ol>
<h4 id="1-mountComponent阶段："><a href="#1-mountComponent阶段：" class="headerlink" title="1. mountComponent阶段："></a>1. mountComponent阶段：</h4><ol>
<li>错误处理方法：performInitialMountWithErrorHandling</li>
<li>初始化挂载方法：performInitialMount<br> i. 如果存在componentWillMount，调用，但是不会触发re-render，而是会进行state合并<br> ii. 如果不是无状态组件，直接开始渲染<br> iii. 得到对应的component类实例</li>
<li>初始化组件，渲染标记，注册事件监听器<br> i. 获取当前元素对应的上下文<br> ii. 初始化公共类<br> iii. 判断组件是否为无状态组件，若是，不会更新队列，只专注于渲染<br> iv. 初始化state<br> v. 错误处理，挂载出错时调用错误处理方法：performInitialMountWithErrorHandling，否则调用初始化挂载方法：performInitialMount方法初始化挂载<br> vi. 最后，如果存在componentDidMount生命周期，调用</li>
</ol>
<h4 id="2-updateComponent阶段"><a href="#2-updateComponent阶段" class="headerlink" title="2. updateComponent阶段"></a>2. updateComponent阶段</h4><pre><code>componentWillRecieveProps， shouldComponentUpdate， componentWillUpdate中调用setstate不会re-render，只会进行state合并，
因为此时的state仍然是未更新数据，获取不到最新的state，所以只有render&amp;compoenntDidUpdate中才能获取到更新后的state</code></pre><ol>
<li>render渲染组件的方法<br> i. 如果需要更新，则继续更新组件，如果不需要，继续渲染，然后拿到更新后的component实例<br> ii. 最后使用render递归渲染</li>
<li>组件确定要更新时，调用即将更新的方法：_performComponentUpdate<br> i. 如果存在componentDidMount，那就将props, state等保存一份<br> ii. 如果存在componentWillUpdate，则调用componentWillUpdate生命周期方法<br> iii. 更新props, state,还有容易忽略的context<br> iv. 调用render组件重新render<br> v. 当组件更新完成之后，如果存在compoenntDidUpdate，则调用</li>
<li>组件更新方法：updateComponent<br> i. 如果存在componentWillRecieveProps，调用<br> ii. 将新的state合并到更新队列，即nextSate就是最新的state<br> iii. 更新队列&amp;shouldComponentUpdate的状态，判断是否需要进行组件更新<br> iv. 确定更新，调用即将更新方法_performComponentUpdate，不确定，更新props,state,context等状态</li>
</ol>
<h4 id="3-unmountComponent阶段"><a href="#3-unmountComponent阶段" class="headerlink" title="3. unmountComponent阶段"></a>3. unmountComponent阶段</h4><pre><code>此时，所有的队列&amp;状态都被重置为null，所以在此处调用setstate不会re-render</code></pre><ol>
<li>如果存在componentWillUnmount，调用</li>
<li>如果组件已经渲染，则对组件进行unmountComponent操作（卸载组件，被渲染组件赋值为null）</li>
<li>执行并重置所有相关参数，更新状态。</li>
</ol>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-virtualDOM" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/10/virtualDOM/">react virtual DOM</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/10/virtualDOM/" class="article-date">
  <time datetime="2020-04-09T17:24:23.000Z" itemprop="datePublished">2020-04-10</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react%E7%9B%B8%E5%85%B3/" rel="tag">react相关</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h4 id="⭐-react源码目录解析"><a href="#⭐-react源码目录解析" class="headerlink" title="⭐ react源码目录解析"></a>⭐ react源码目录解析</h4><p><img src="https://b.bdstatic.com/searchbox/icms/searchbox/img/react%E6%BA%90%E7%A0%81%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="react源码目录解析"></p>
<h4 id="⭐-virtual-DOM-是什么？"><a href="#⭐-virtual-DOM-是什么？" class="headerlink" title="⭐ virtual DOM 是什么？"></a>⭐ virtual DOM 是什么？</h4><ul>
<li>virtual DOM实际上是浏览器端通过JS实现的一套DOM API（为了解决频繁的数据更新引来的性能问题）</li>
<li>基于react进行开发时，所有的DOM树都是通过virtual DOM构造的，react的所有工作都是基于virtual DOM来完成的</li>
<li>react 在virtualDOM上实现了diff算法，数据更新时，会通过diff来寻找更新节点，只对变化的部分进行浏览器的DOM更新</li>
<li>因为virtual DOM只是一个JS 对象，而且面对原生DOM进行操作的只是数据变更的节点，所以能够达到提高性能的目的</li>
</ul>
<p>构建一个简易的virtual DOM，只需要具备一个DOM标签所需要的基本元素即可</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; eg</span><br><span class="line">let reactDOM &#x3D; &#123;</span><br><span class="line">    tagName: &#39;div&#39;,</span><br><span class="line">    properties: &#123;</span><br><span class="line">        style: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [],</span><br><span class="line">    key: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h4 id="⭐-virtual-DOM的节点类型"><a href="#⭐-virtual-DOM的节点类型" class="headerlink" title="⭐ virtual DOM的节点类型"></a>⭐ virtual DOM的节点类型</h4><ul>
<li>virtual DOM中的节点称为react DOM，分为reactElement，reactFragment，reactText</li>
<li>其中reactElement又分为reactComponentElement，reactDomElement</li>
<li>可以用代码描述<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">reactNode &#x3D; reactElement | reactFragment | reactText;</span><br><span class="line">reactElement &#x3D; reactComponentElement | reactDomElement;</span><br><span class="line">reactDomElement &#x3D; &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    props: &#123;</span><br><span class="line">        children: reactNodeList,</span><br><span class="line">        style: String,</span><br><span class="line">        etc</span><br><span class="line">    &#125;,</span><br><span class="line">    key: String | Boolean | Number | null,</span><br><span class="line">    ref: String | null</span><br><span class="line">&#125;;</span><br><span class="line">reactComponentElement&lt;Tprops&gt; &#x3D; &#123;</span><br><span class="line">    type: ReactClass&lt;Tprops&gt;,</span><br><span class="line">    peops: Tprops,</span><br><span class="line">    key: String | Boolean | Number | null,</span><br><span class="line">    ref: String | null</span><br><span class="line">&#125;;</span><br><span class="line">reactFragment &#x3D; Array&lt;reactNode | reactEmpty&gt;;</span><br><span class="line">reactText &#x3D; String | Number;</span><br><span class="line">reactNodeList &#x3D; reactNode | reactEmpty;</span><br><span class="line">reactEmpty &#x3D; null | undefined | Boolean;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<hr>
<h4 id="⭐-怎么样可以实现一个virtual-DOM呢？分为以下几步"><a href="#⭐-怎么样可以实现一个virtual-DOM呢？分为以下几步" class="headerlink" title="⭐ 怎么样可以实现一个virtual DOM呢？分为以下几步"></a>⭐ <strong>怎么样可以实现一个virtual DOM呢？分为以下几步</strong></h4><ol>
<li>创建react元素；</li>
<li>初始化组件入口；</li>
<li>创建文本组件</li>
<li>创建DOM标签组件</li>
<li>自定义组件</li>
<li>最后在有数据或者DOM更新时，使用diff算法去寻找变更的virtual DOM更新到真实DOM中（这里的diff算法稍后再说）</li>
</ol>
<hr>
<pre><code>接下来伪代码简要概述实现过程</code></pre><h4 id="1-创建react元素-通过JSX创建的虚拟元素最终都会被编译成调用react的creatElement方法"><a href="#1-创建react元素-通过JSX创建的虚拟元素最终都会被编译成调用react的creatElement方法" class="headerlink" title="1. 创建react元素: 通过JSX创建的虚拟元素最终都会被编译成调用react的creatElement方法"></a>1. 创建react元素: 通过JSX创建的虚拟元素最终都会被编译成调用react的creatElement方法</h4><ul>
<li>creatElement只是做了简单的参数修正，返回一个reactElement(虚拟元素)实例<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">reactElement.creatElement &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; a. 初始化参数</span><br><span class="line">    let propName, props, key, ref, self, source;</span><br><span class="line">    &#x2F;&#x2F; b. 如果config存在，提取里面的内容</span><br><span class="line">    if(config) &#123;</span><br><span class="line">        &#x2F;&#x2F; 提取config的内容，config.ref, config.key等</span><br><span class="line">        &#x2F;&#x2F; 复制config里面的内容到props（id, className）</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; c. 处理children，全部挂载到props的children属性上</span><br><span class="line">    let childrenLength &#x3D; arguments.length - 2;</span><br><span class="line">    if(childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果只有一个参数，直接赋值</span><br><span class="line">    &#125; else if(childrenLength &gt; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 合并处理</span><br><span class="line">        let childrenArray &#x3D; Array(childrenLength);</span><br><span class="line">        props.children &#x3D; childrenArray;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; d. 返回一个reactElement实例对象</span><br><span class="line">    return reactElement(type, key, ref, self, source, reactCurrentOwner.current, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h4 id="2-初始化组件入口-当react组件初始化时，会调用初始化函数instantiateReactComponent"><a href="#2-初始化组件入口-当react组件初始化时，会调用初始化函数instantiateReactComponent" class="headerlink" title="2. 初始化组件入口: 当react组件初始化时，会调用初始化函数instantiateReactComponent"></a>2. 初始化组件入口: 当react组件初始化时，会调用初始化函数instantiateReactComponent</h4><ul>
<li>instantiateReactComponent这个函数通过判断node类型来区分不同的组件入口<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function instantiateReactComponent(node, compositeType) &#123;</span><br><span class="line">    let instance;</span><br><span class="line">    if(node &#x3D;&#x3D;&#x3D; null || node &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">        &#x2F;&#x2F; node为空时，初始化空组件</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof node &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; node是对象时，是DOM标签组件&#x2F;自定义组件</span><br><span class="line">        if(typeof Element.type &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F; element类型为字符串时，初始化DOM标签组件</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 初始化自定义组件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof node &#x3D;&#x3D;&#x3D; &#39;string&#39; || typeof node &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化文本组件</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 其他类型不做处理</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h4 id="3-创建文本组件：创建组件-–-判断创建方式-–-更新文本内容"><a href="#3-创建文本组件：创建组件-–-判断创建方式-–-更新文本内容" class="headerlink" title="3. 创建文本组件：创建组件 – 判断创建方式 – 更新文本内容"></a>3. 创建文本组件：创建组件 – 判断创建方式 – 更新文本内容</h4><ul>
<li>通过createElement来创建的文本组件，会被带上标签和domID，否则直接返回文本内容<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 通过createElement来创建的文本组件，会被带上标签和domID，否则直接返回文本内容</span><br><span class="line">let ReactDOMTextComponent &#x3D; function (next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 先保存当前的文本字符</span><br><span class="line">    &#x2F;&#x2F; 再给文本字符添加属性</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 2. 给ReactDOMTextComponent的原型添加mountComponent方法，判断创建方式</span><br><span class="line">Object.assign(ReactDOMTextComponent.prototype, &#123;</span><br><span class="line">    mountComponent: function(transaction, nativeParent, nativeContainerInfo, context) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果使用createElement来创建文本标签，该文本会带上标签和domId</span><br><span class="line">        if(transaction.useCreatElement) &#123;</span><br><span class="line">            &#x2F;&#x2F; 开始标签 -- 创建文本节点 -- 结束标签</span><br><span class="line">            return &#39;带标签的文本&#39;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 静态页面直接返回文本</span><br><span class="line">            if(transaction.renderToStaticMarkup) &#123;</span><br><span class="line">                return &#39; &#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            return &#39;注释掉标签的文本内容&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 3. 更新文本内容</span><br><span class="line">reveiveComponent &#x3D; function(nextComponent, transaction) &#123;</span><br><span class="line">    if(nextText !&#x3D;&#x3D; this.currentElement) &#123;</span><br><span class="line">        &#x2F;&#x2F; replace</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h4 id="4-创建DOM标签组件-reactDOMComponent针对virtual-DOM标签的处理主要分为以下两个部分："><a href="#4-创建DOM标签组件-reactDOMComponent针对virtual-DOM标签的处理主要分为以下两个部分：" class="headerlink" title="4. 创建DOM标签组件: reactDOMComponent针对virtual DOM标签的处理主要分为以下两个部分："></a>4. 创建DOM标签组件: reactDOMComponent针对virtual DOM标签的处理主要分为以下两个部分：</h4><pre><code>1. 属性的更新（包括样式更新，属性更新，事件处理等）
2. 子节点的更新（包括更新内容，更新子节点，diff实现）</code></pre><p>（源码实现有点多，大概节奏如上，还没来得及梳理…）</p>
<h4 id="5-自定义组件"><a href="#5-自定义组件" class="headerlink" title="5. 自定义组件:"></a>5. 自定义组件:</h4><pre><code>reactCompositeComponent自定义组件实现了一整套的react生命周期和setState机制
即自定义组件是在生命周期的环境中进行的更新属性，内容和子节点的操作，与reactDOMComponent类似</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-hocRenderHook" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/03/hocRenderHook/">对比分析HOC,render props,react hook</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/03/hocRenderHook/" class="article-date">
  <time datetime="2020-04-03T04:40:23.000Z" itemprop="datePublished">2020-04-03</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react%E7%9B%B8%E5%85%B3/" rel="tag">react相关</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <ul>
<li>前两天刚看了HOC相关内容，所以今天就来对比分析HOC  render props  hook三种模式的区别</li>
<li>接下来会用伪代码实现相关功能，由于hook是2020新出的一种模式,因为不太了解，所以会着重注释说明</li>
</ul>
<h3 id="1-HOC高阶组件"><a href="#1-HOC高阶组件" class="headerlink" title="1. HOC高阶组件"></a>1. HOC高阶组件</h3><ul>
<li>创建一个方法，该方法接收一个组件作为参数，&amp;除了组件，还可以接收其他参数. 基于该组件，可以返回一个不同的组件<br>  a. 优点：不影响组件内结构，降低耦合度<br>  b. 缺点：如果高阶组件和当前组件内数据定义相同，那么props会被覆盖<br>  c. 解决：尽可能的对高阶组件的props重命名以免混淆，这样当前组件内就会多一个高阶组件的props。但是这样的话，就会引入更多的props，比较难调试<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const myContainer &#x3D; (wrappedComponent, selectData) &#x3D;&gt; &#123;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state &#x3D; selectData(data, props);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;wrappedComponent &#123;...this.props&#125; &#123;...this.state.data&#125; &#x2F;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class myComponent extends Component &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">export default myContainer(myComponent);</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="2-render-props"><a href="#2-render-props" class="headerlink" title="2. render props"></a>2. render props</h3><ul>
<li>把当前组件的state作为props传递给调用组件，由调用组件决定渲染<br>  a. 实现：接收一个外部传来的props属性，将内部state作为props传递给调用组件<br>  b. 缺点：显而易见，无法在return外访问数据, 并且页面层级一多，容易形成嵌套地域…<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyContainer extends Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            x: 0,</span><br><span class="line">            y: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.props.render(this.state)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">class myComponent extends Component &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;MyContainer render&#x3D;&#123;container &#x3D;&gt; (</span><br><span class="line">            &lt;p&gt;&#123;container.x&#125; &#123;container.y&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        )&#125; &#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="3-react-hook"><a href="#3-react-hook" class="headerlink" title="3. react hook"></a>3. <a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">react hook</a></h3><ul>
<li>hook: react 16.8的新特性，可以在不编写class的情况下使用state，生命周期等react特性</li>
<li>是特殊的钩子函数，是一些可以在函数组件里“钩入” React state 及生命周期等特性的函数</li>
<li>在无需修改组件结构的情况下复用状态逻辑</li>
<li>动机：解决上述模式(HOC, render props)的缺点，为共享状态逻辑添加更简单的原生方法</li>
<li>hook与class平级，可以在非 class 的情况下可以使用更多的 React 特性，避免了class的一些缺点</li>
<li>hook在class内部不起作用，但是可以用hook来代替class</li>
<li>优点：<br>  可以在return之外使用,也不会去嵌套使用<br>  避免了class组件的一些冗余的生命周期操作，并且可以把相关逻辑写在一起，分离不相关的逻辑<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState, useEffect&#125; from &#39;react&#39;;</span><br><span class="line">export const Example &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 在函数组件中添加state的hook,等价于class组件中的this.setState</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">    const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line">    &#x2F;&#x2F; effect hook is Similar to componentDidMount and componentDidUpdate</span><br><span class="line">    &#x2F;&#x2F; useEffect可以实现关注点分离，把不相关的逻辑分离到不同的useEffect中</span><br><span class="line">    &#x2F;&#x2F; useEffect默认处理清除更新逻辑，在调用新的effect之前对前一个effect进行清理</span><br><span class="line">    &#x2F;&#x2F; 对于不需要清除的effect(即不需要componentWillUnmount)</span><br><span class="line">        &#x2F;&#x2F; useEffect默认每次渲染后都会执行</span><br><span class="line">        &#x2F;&#x2F; 每次渲染都会生成新的effect，来替换之前的effect</span><br><span class="line">        &#x2F;&#x2F; 使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕</span><br><span class="line">    &#x2F;&#x2F; 对于需要清除的effect</span><br><span class="line">        &#x2F;&#x2F; 可以返回一个函数，在组件卸载时调用,执行清除操作</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 相当于componentDidMount and componentDidUpdate的实现</span><br><span class="line">        document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">    &#125;, [count]); &#x2F;&#x2F; count：可选参数，旨在只有count改变时才会更新</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取状态的方法 handler方法</span><br><span class="line">        &#x2F;&#x2F; 类似于componentDidMount，去订阅状态</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 相当于componentWillUnmount，卸载组件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">© 2020</span><br></pre></td></tr></table></figure></div></li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-jsArray" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/jsArray/">原生JS实现常见高阶数组方法</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/02/jsArray/" class="article-date">
  <time datetime="2020-04-02T09:40:23.000Z" itemprop="datePublished">2020-04-02</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E7%94%9FJS/" rel="tag">原生JS</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <ul>
<li>在实现之前，我们先来介绍一下高阶函数：可以接收另外一个函数作为参数或者返回值的函数</li>
<li>那么高阶数组方法也是高阶函数</li>
</ul>
<h3 id="1-实现一个map方法"><a href="#1-实现一个map方法" class="headerlink" title="1. 实现一个map方法"></a>1. 实现一个map方法</h3><ul>
<li>map：接收两个参数，一个是回调函数，一个是this（可选）, 并且对原数组没有影响</li>
<li>可以先捋一下实现思路<ol>
<li>首先肯定是将map方法挂在数组原型上，并且接收两个参数，如上所说</li>
<li>先对this，callback做容错处理，严谨一点</li>
<li>将参数强转为对象</li>
<li>创建一个新的数组，不用改变原数组</li>
<li>for…in…循环遍历</li>
</ol>
</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map &#x3D; function(callbackFn, thisArg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理this异常</span><br><span class="line">    if(this &#x3D;&#x3D;&#x3D; null || this &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot read property &#39;map&#39; of null or undefined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(Object.prototype.toString.call(callbackFn) !&#x3D;&#x3D; &#39;[object Function]&#39;) &#123;</span><br><span class="line">        throw new TypeError(&quot;callbackFn is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let o &#x3D; Object(this);</span><br><span class="line">    let t &#x3D; thisArg;</span><br><span class="line"></span><br><span class="line">    let length &#x3D; o.length &gt;&gt;&gt; 0;</span><br><span class="line">    let array &#x3D; new Array(length);</span><br><span class="line"></span><br><span class="line">    for(let k &#x3D; 0; k &lt; length; k++) &#123;</span><br><span class="line">        if(k in o) &#123;</span><br><span class="line">            let value &#x3D; o[k];</span><br><span class="line">            &#x2F;&#x2F; 依次传入this, 当前项，索引，整个数组</span><br><span class="line">            let mappedValue &#x3D; callbackFn.call(t, value, k, o);</span><br><span class="line">            array[k] &#x3D; mappedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let arrayq &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">let newArray &#x3D; arrayq.map((item, index) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(item, index);</span><br><span class="line">    return item * index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(newArray);</span><br><span class="line">&#x2F;&#x2F; 1 0</span><br><span class="line">&#x2F;&#x2F; 2 1</span><br><span class="line">&#x2F;&#x2F; 3 2</span><br><span class="line">&#x2F;&#x2F; 4 3</span><br><span class="line">&#x2F;&#x2F; 5 4</span><br><span class="line">&#x2F;&#x2F; [0, 2, 6, 12, 20]</span><br></pre></td></tr></table></figure></div>

<h3 id="2-实现一个reduce方法"><a href="#2-实现一个reduce方法" class="headerlink" title="2. 实现一个reduce方法"></a>2. 实现一个reduce方法</h3><ul>
<li>reduce：接收两个参数，一个是回调函数，一个是初始值（可选）, 并且对原数组没有影响</li>
<li>可以先捋一下实现思路<ol>
<li>首先肯定是将map方法挂在数组原型上，并且接收两个参数，如上所说</li>
<li>先对this，callback做容错处理，严谨一点</li>
<li>将参数强转为对象</li>
<li>初始化兼容，如果没有传初始值，默认选数组第一项作为初始值</li>
<li>for…in…循环遍历数组，实现累加<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.reduce &#x3D; function(callbackFn, currentValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理this异常</span><br><span class="line">    if(this &#x3D;&#x3D;&#x3D; null || this &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot read property &#39;map&#39; of null or undefined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 处理回调异常</span><br><span class="line">    if(Object.prototype.toString.call(callbackFn) !&#x3D;&#x3D; &#39;[object Function]&#39;) &#123;</span><br><span class="line">        throw new TypeError(&quot;&#96;$&#123;callbackFn&#125;&#96; is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let o &#x3D; Object(this);</span><br><span class="line">    let accumulator &#x3D; currentValue;</span><br><span class="line">    let k &#x3D; 0;</span><br><span class="line">    if(accumulator &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        for(; k &lt; o.length; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找原型链</span><br><span class="line">            if(k in o) &#123;</span><br><span class="line">                accumulator &#x3D; o[k];</span><br><span class="line">                k++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 数组循环完还没有出逻辑，说明数组是空数组</span><br><span class="line">            throw new Error(&#39;empty array&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(; k &lt; o.length; k++) &#123;</span><br><span class="line">        if(k in o) &#123;</span><br><span class="line">            accumulator &#x3D; callbackFn.call(undefined, accumulator, o[k], k, o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return accumulator;</span><br><span class="line">&#125;</span><br><span class="line">let array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">let reduceArray &#x3D; array.reduce((preNum, curNum) &#x3D;&gt; &#123;</span><br><span class="line">    return preNum + curNum;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(reduceArray);</span><br><span class="line">&#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure></div>

</li>
</ol>
</li>
</ul>
<h3 id="3-实现一个filter方法"><a href="#3-实现一个filter方法" class="headerlink" title="3. 实现一个filter方法"></a>3. 实现一个filter方法</h3><ul>
<li>filter: filter返回一个新的数组，数组里包含参数里所有被保留的项</li>
<li>这个方法只接收一个参数，就是数组的当前项,回调函数返回一个布尔类型，来决定当前参数的去留<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.filter &#x3D; function(callbackFn, thisArg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理this异常</span><br><span class="line">    if(this &#x3D;&#x3D;&#x3D; null || this &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot read property &#39;map&#39; of null or undefined&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 处理回调异常</span><br><span class="line">    if(Object.prototype.toString.call(callbackFn) !&#x3D;&#x3D; &#39;[object Function]&#39;) &#123;</span><br><span class="line">        throw new TypeError(&quot;&#96;$&#123;callbackFn&#125;&#96; is not a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    let o &#x3D; Object(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 新数组</span><br><span class="line">    let length &#x3D; 0;</span><br><span class="line">    let array &#x3D; [];</span><br><span class="line">    for(let i &#x3D; 0; i &lt; o.length; i++) &#123;</span><br><span class="line">        if(i in o) &#123;</span><br><span class="line">            if(callbackFn.call(thisArg, o[i], i, o)) &#123;</span><br><span class="line">                array[length++] &#x3D; o[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line">let array &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">let filterArray &#x3D; array.filter(item &#x3D;&gt; item % 2);</span><br><span class="line">console.log(filterArray);</span><br><span class="line">&#x2F;&#x2F; [1, 3, 5]</span><br></pre></td></tr></table></figure></div></li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-react_component" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/react_component/">react组件间抽象</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/02/react_component/" class="article-date">
  <time datetime="2020-04-02T06:24:23.000Z" itemprop="datePublished">2020-04-02</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react%E7%9B%B8%E5%85%B3/" rel="tag">react相关</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h4 id="1-mixin：抽象公共方法"><a href="#1-mixin：抽象公共方法" class="headerlink" title="1. mixin：抽象公共方法"></a>1. mixin：抽象公共方法</h4><h5 id="⭐-为什么使用mixin"><a href="#⭐-为什么使用mixin" class="headerlink" title="⭐ 为什么使用mixin"></a>⭐ 为什么使用mixin</h5><pre><code>mixin，是将一个模块混入另外一个模块/类中。引入mixin，是为了创造一种类似多重继承的效果。</code></pre><h5 id="⭐自己封装一个mixin方法"><a href="#⭐自己封装一个mixin方法" class="headerlink" title="⭐自己封装一个mixin方法"></a>⭐自己封装一个mixin方法</h5><pre><code>对于广义的mixin方法，就是用赋值的方法将mixin对象里的方法都挂载到原对象中，来实现对对象的混入</code></pre><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const mixin &#x3D; (obj, mixins) &#x3D;&gt; &#123;</span><br><span class="line">    const newObj &#x3D; obj;</span><br><span class="line">    newObj.prototype &#x3D; Object.creat(obj.prototype);</span><br><span class="line">    for(let prop in mixins) &#123;</span><br><span class="line">        if(mixins.hasOwnProperty(prop)) &#123;</span><br><span class="line">            newObj.prototype[prop] &#x3D; mixins[props];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line">const bigMixin &#x3D; &#123;</span><br><span class="line">    fly: () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;I can fly&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const big &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;new big&#39;);</span><br><span class="line">&#125;</span><br><span class="line">const FlyBig &#x3D; mixin(big, bigMixin);</span><br><span class="line">const flyBig &#x3D; new FlyBig();    &#x2F;&#x2F; new big</span><br><span class="line">flyBig.fly();   &#x2F;&#x2F; I can fly</span><br></pre></td></tr></table></figure></div>
<pre><code>通俗来讲，上述代码的作用是把任意多个源对象自身的可枚举属性复制给目标对象，再返回给目标对象。上述过程就像是在复制对象</code></pre><h5 id="⭐-react中使用mixin"><a href="#⭐-react中使用mixin" class="headerlink" title="⭐ react中使用mixin"></a>⭐ react中使用mixin</h5><p>react在使用creatClass构建组件时提供了mixin属性。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">react.creatClass &#x3D; &#123;</span><br><span class="line">    mixin: []</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;foo&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<pre><code>在creatClass 对象参数中传入数组mixins，里面封装了我们需要的模块，mixins数组也可以增加多个mixin,并且其中的每一个mixin方法都有重合，对于普通方法和生命周期方法是有所区分的

在不同的mixin里实现两个名字一样的普通方法，讲道理后一个是可以覆盖前一个方法的，但是在react中会报错，因为在react中是不允许存在重名普通方法的maxin</code></pre><ul>
<li>creatClass实现的mixin为react组件实现了两件事<ol>
<li>工具方法：mixin的基本功能</li>
<li>生命周期继承：props与state合并，比如有很多mixin来定义componentdidmount这个生命周期钩子，那么react会非常智能的把它们合并起来执行<h5 id="⭐-mixin的问题"><a href="#⭐-mixin的问题" class="headerlink" title="⭐ mixin的问题"></a>⭐ mixin的问题</h5></li>
</ol>
</li>
</ul>
<ol>
<li>破坏了原有组件的封装：mixin方法会混入新的方法，给原有的组件带来新的特性，会需要很多不可见的状态需要去维护</li>
<li>命名冲突：mixin是平面结构，不能在两个mixin里面使用同一个方法</li>
<li>增加复杂性：mixin也有自己的生命周期方法</li>
</ol>
<h4 id="2-高阶组件-–-取代mixin"><a href="#2-高阶组件-–-取代mixin" class="headerlink" title="2. 高阶组件 – 取代mixin"></a>2. 高阶组件 – 取代mixin</h4><p>高阶组件有两种实现方式：</p>
<pre><code>1. 属性代理：高阶组件通过被包裹的react组件来操作props
2. 反向继承：高阶组件继承于被包裹的react组件</code></pre><h5 id="1-属性代理"><a href="#1-属性代理" class="headerlink" title="1. 属性代理"></a>1. 属性代理</h5><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const myContainer &#x3D; (wrappedComponent) &#x3D;&gt; &#123;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;wrappedComponent &#123;...this.props&#125; &#x2F;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class myComponent extends Component &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">export default myContainer(myComponent);</span><br></pre></td></tr></table></figure></div>
<pre><code>当使用组件代理实现高阶组件时，执行生命周期的过程类似于堆栈调用
高阶组件可以做到对组件的控制，包括props，通过refs使用引用，抽象state等</code></pre><ul>
<li><p>控制props</p>
<p>  我们应该尽可能的对高阶组件的props重命名以免混淆。对于原组件来说，只要套用这个高阶组件，我们的新组件中就会多一个text的prop</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const myContainer &#x3D; (wrappedComponent) &#x3D;&gt; &#123;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const newProps &#x3D; &#123;</span><br><span class="line">                text: newText</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;wrappedComponent &#123;...this.props&#125; &#123;...this.newProps&#125; &#x2F;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>通过refs使用引用</p>
<p>  当wrappedComponent被渲染时，refs回调就会被执行，这样的话就会拿到wrappedComponent实例的引用，也会更方便的调用实例的方法</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const myContainer &#x3D; (wrappedComponent) &#x3D;&gt; &#123;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        proc(wrappedComponentTnstance) &#123;</span><br><span class="line">            wrappedComponentTnstance.method()</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const props &#x3D; Object.assign(&#123;&#125;, this.props, &#123;</span><br><span class="line">                this.refs.bind(this)</span><br><span class="line">            &#125;);</span><br><span class="line">            return &lt;wrappedComponent &#123;...this.props&#125; &#x2F;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>抽象state</p>
<p>  通过wrappedComponent提供的props和回调抽象state，将原组件抽象成展示组件，分离内部状态</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const myContainer &#x3D; (wrappedComponent) &#x3D;&gt; &#123;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state &#x3D; &#123;</span><br><span class="line">                name: &#39;&#39;</span><br><span class="line">            &#125;</span><br><span class="line">            this.onNameChange &#x3D; this.onNameChange.bind(this);</span><br><span class="line">        &#125;</span><br><span class="line">        onNameChange(event) &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                name: event.target.value</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const newProps &#x3D; &#123;</span><br><span class="line">                name: &#123;</span><br><span class="line">                    value: this.state.name,</span><br><span class="line">                    onChange: this.onNameChange</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;wrappedComponent &#123;...this.props&#125; &#123;...this.newProps&#125; &#x2F;&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p>高阶组件与mixin的区别</p>
<p>  高阶组件符合函数式编程思想，对于原组件来说，并不会感知到高阶组件的存在</p>
<h5 id="2-反向继承"><a href="#2-反向继承" class="headerlink" title="2. 反向继承"></a>2. 反向继承</h5></li>
</ul>
<h4 id="3-组合式组件开发实践"><a href="#3-组合式组件开发实践" class="headerlink" title="3. 组合式组件开发实践"></a>3. 组合式组件开发实践</h4><ol>
<li>组件再分离</li>
<li>逻辑再抽象</li>
</ol>
<p>我们平时开发中就遵循这种逻辑，将组件拆分成最细化的原子组件，通过拆分组合的方式实现一个个功能组件，然后再基于高阶组件完成组件逻辑上的抽象</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-react_cssModule" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/react_cssModule/">react样式处理&amp;CSS module</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/01/react_cssModule/" class="article-date">
  <time datetime="2020-04-01T13:24:23.000Z" itemprop="datePublished">2020-04-01</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react%E7%9B%B8%E5%85%B3/" rel="tag">react相关</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <ul>
<li>本节样式处理的重点在CSS module</li>
</ul>
<h4 id="1-css基本样式设置"><a href="#1-css基本样式设置" class="headerlink" title="1. css基本样式设置"></a>1. css基本样式设置</h4><blockquote>
<h5 id="1-行内样式设置"><a href="#1-行内样式设置" class="headerlink" title="1. 行内样式设置"></a>1. 行内样式设置</h5><pre><code>1. 自定义组件建议支持className，尽量不使用行内样式
2. 设置行内样式时需要使用对象</code></pre></blockquote>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const style &#x3D; &#123;</span><br><span class="line">    color: white,</span><br><span class="line">    backgroundImage: &#96;$&#123;url(imgUrl)&#125;&#96;,</span><br><span class="line">    &#x2F;&#x2F; 这里的大写会转换成-webkit-transition</span><br><span class="line">    WebkitTransition: &#39;all&#39;,</span><br><span class="line">    &#x2F;&#x2F; ms是唯一小写的浏览器前缀</span><br><span class="line">    msTransition: &#39;all&#39;</span><br><span class="line">&#125;</span><br><span class="line">const component &#x3D; &lt;component style&#x3D;&#123;style&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<h5 id="2-样式中的像素值"><a href="#2-样式中的像素值" class="headerlink" title="2. 样式中的像素值"></a>2. 样式中的像素值</h5><pre><code>1. react会自动为与大小有关的样式属性添加px，所以在写行内样式时可以不带单位</code></pre><h5 id="3-使用classnames库"><a href="#3-使用classnames库" class="headerlink" title="3. 使用classnames库"></a>3. 使用classnames库</h5></blockquote>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; classnames类库使得类名操作变得简单</span><br><span class="line">import React, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line">import classNames from &#39;classnames&#39;;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class button extends component &#123;</span><br><span class="line">    render &#123;</span><br><span class="line">        const btnClass &#x3D; &#123;</span><br><span class="line">            &#39;btn&#39;: true,</span><br><span class="line">            &#39;btn_pressed&#39;: this.state.isPressed,</span><br><span class="line">            &#39;btn_over&#39;: !this.state.isPressed &amp;&amp; this.state.isHover</span><br><span class="line">        &#125;</span><br><span class="line">        return &lt;button className&#x3D;&#123;btnClass&#125;&gt;&#123;this.state.label&#125;&lt;&#x2F;button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-CSS-module"><a href="#2-CSS-module" class="headerlink" title="2. CSS module"></a>2. CSS module</h4><hr>
<h5 id="1-CSS模块化目前的两种主流解决方案"><a href="#1-CSS模块化目前的两种主流解决方案" class="headerlink" title="1. CSS模块化目前的两种主流解决方案"></a>1. CSS模块化目前的两种主流解决方案</h5><p>✨ <code>inline style</code></p>
<pre><code>优点：彻底抛弃CSS，使用JS或者json来写样式，给CSS提供同JS同样强大的模块化功能

缺点：几乎不能利用CSS的本身特性，对于伪元素，媒体查询等CSS特性的处理变得复杂，并且需要依赖框架实现</code></pre><p>✨   <code>CSS Module</code></p>
<pre><code>依旧使用CSS，但是使用JS来管理样式依赖，最大程度的结合现有CSS生态&amp;JS模块化能力。

发布时依旧编译出单独的JS&amp;CSS文件。

目前，webpack css-loader已经内置了SS Module`功能</code></pre><h5 id="2-CSS模块化遇到的问题"><a href="#2-CSS模块化遇到的问题" class="headerlink" title="2. CSS模块化遇到的问题"></a>2. CSS模块化遇到的问题</h5><blockquote>
<p>CSS 模块化最重要的是CSS样式的导入和导出，灵活导入以便复用，导出时要能够隐藏内部作用域，以免全局污染</p>
</blockquote>
<pre><code>1. 全局污染：方便重写样式，但所有的样式都全局生效。
2. 命名混乱：多人开发容易导致命名混乱
3. 依赖管理不彻底：除了引入JS，还要引入它的CSS，并且less/sass不能对每个组件都编译出单独的CSS，引入所有模块的CSS又比较浪费
4. 无法共享变量：预编译语言无法提供跨JS&amp;CSS共享变量的能力
5. 代码压缩不彻底：比如多人开发情况下的超长类名...</code></pre><h5 id="3-CSS-Modules模块化方案"><a href="#3-CSS-Modules模块化方案" class="headerlink" title="3. CSS Modules模块化方案"></a>3. <code>CSS Modules</code>模块化方案</h5><ul>
<li>CSS Module内部通过ICSS来解决样式的导入&amp;导出问题，分别对应:import  &amp;  :export两个伪类<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:import(&#39;path&#x2F;style.css&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">:export &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>但是CSS Modules通常用JS来管理CSS的能力，在JS文件中导入</li>
</ul>
<h4 id="3-CSS-module的使用-结合webpack-css-loader"><a href="#3-CSS-module的使用-结合webpack-css-loader" class="headerlink" title="3. CSS module的使用(结合webpack css-loader)"></a>3. CSS module的使用(结合webpack css-loader)</h4><hr>
<h5 id="1-css-modules的启用"><a href="#1-css-modules的启用" class="headerlink" title="1. css modules的启用"></a>1. css modules的启用</h5><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.config.js</span><br><span class="line">&#x2F;&#x2F; 在配置文件里加上modules即为启用，localIndentName是设置命名规则</span><br><span class="line">css?modules&amp;localIndentName&#x3D;[name]__[local]-[hash:base64:5]</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 接下来引入css&amp;转化class名</span><br><span class="line">&#x2F;* component&#x2F;button.css *&#x2F;</span><br><span class="line">.nomal&#123;&#125;</span><br><span class="line">.disabled&#123;&#125;</span><br><span class="line">&#x2F;* component.button.js *&#x2F;</span><br><span class="line">import styles from &#39;.&#x2F;button.css&#39;;</span><br><span class="line">console.log(styles);</span><br><span class="line">&#x2F;&#x2F; console出来的style是一个对象，并且是根据localIndentName命名规则自动生成的class名</span><br><span class="line">&#x2F;* object: &#123;</span><br><span class="line">    nomal: &#39;button--nomal-abc3536&#39;,</span><br><span class="line">    disabled: &#39;button--disabled-def5867&#39;</span><br><span class="line">&#125; *&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">buttonElement.outerHTML &#x3D; &lt;button type&#x3D;&quot;submit&quot; class&#x3D;$&#123;styles.nomal&#125;&gt;submit&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;最终编译的HTML是这样的</span><br><span class="line">&lt;button type&#x3D;&quot;submit&quot; class&#x3D;&#39;button--nomal-abc3536&#39;&gt;submit&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>css module通过上述处理，实现了以下几点：<ol>
<li>样式都是局部化的,解决了命名冲突和全局污染问题</li>
<li>class名生成规则配置灵活，可以借此压缩类名</li>
<li>只需引入组件的JS，就可以搞定组件的JS&amp;CSS</li>
</ol>
</li>
</ul>
<h5 id="2-默认样式为局部样式"><a href="#2-默认样式为局部样式" class="headerlink" title="2. 默认样式为局部样式"></a>2. 默认样式为局部样式</h5><ul>
<li>css module默认样式为局部样式，即默认给所有的样式名外加了:local，如果想切换到全局样式，用:global包裹<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">:local(.nomal) &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义单个全局样式</span><br><span class="line">:global(.btn) &#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 定义多个全局样式</span><br><span class="line">:global &#123;</span><br><span class="line">    .link &#123;&#125;</span><br><span class="line">    .box&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h5 id="3-使用composes组合样式"><a href="#3-使用composes组合样式" class="headerlink" title="3. 使用composes组合样式"></a>3. 使用composes组合样式</h5><ul>
<li><p>css module提供了一种方式用于样式复用：composes</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种使用方式：使用内部文件样式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;* components&#x2F;button.css *&#x2F;</span><br><span class="line">.base &#123;&#125;</span><br><span class="line">.nomal &#123;</span><br><span class="line">    composes: base</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.disable &#123;</span><br><span class="line">    composes: base</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; js里</span><br><span class="line">import styles from &#39;.&#x2F;button.css&#39;;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">button.innerHTMl &#x3D; &lt;button type&#x3D;&#39;submit&#39; class&#x3D;$&#123;styles.nomal&#125;&gt;submit&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F; 最终生成的HTML如下</span><br><span class="line">&lt;button type&#x3D;&#39;submit&#39; class&#x3D;&#39;button--base-abc53 button--nomal-abc53&#39;&gt;submit&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 第二种使用方式：引用外部文件样式</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;* setting.css *&#x2F;</span><br><span class="line">.primary-color &#123;&#125;</span><br><span class="line">&#x2F;* components&#x2F;button.css *&#x2F;</span><br><span class="line">.base &#123;&#125;</span><br><span class="line">.primary &#123;</span><br><span class="line">    composes: base;</span><br><span class="line">    composes: $primary-color from &#39;setting.css&#39;;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>  使用问题：由于composes不是标准的CSS语法，编译时会报错，所以只能使用预处理器自己的语法来处理样式复用</p>
<h5 id="4-实现CSS与JS变量共享"><a href="#4-实现CSS与JS变量共享" class="headerlink" title="4. 实现CSS与JS变量共享"></a>4. 实现CSS与JS变量共享</h5><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* config.scss *&#x2F;</span><br><span class="line">$primary-color: #fff;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">:export &#123;</span><br><span class="line">    ptimaryColor: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;* app.js *&#x2F;</span><br><span class="line">import style from &#39;.&#x2F;config.scss&#39;;</span><br><span class="line">&#x2F;&#x2F; 会输出#fff</span><br><span class="line">console.log(style.ptimaryColor);</span><br></pre></td></tr></table></figure></div>
<h5 id="5-css-module使用技巧"><a href="#5-css-module使用技巧" class="headerlink" title="5. css module使用技巧"></a>5. css module使用技巧</h5></li>
<li><p>CSS module是对现有的CSS做减法，其中可以参考的建议使用规则如下：</p>
<ol>
<li><p>不使用选择器，只使用class来定义样式</p>
</li>
<li><p>不层叠多个class，只使用一个class把所有样式定义好</p>
</li>
<li><p>所有的样式通过composes来实现复用</p>
</li>
<li><p>不嵌套</p>
<blockquote>
<p>注意：css module只会转换class名相关的样式</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h5 id="6-如何与全局样式实现共存"><a href="#6-如何与全局样式实现共存" class="headerlink" title="6. 如何与全局样式实现共存"></a>6. 如何与全局样式实现共存</h5><ul>
<li>前端项目中总会引入一些base.css一类的全局css文件,使用webpack可以使全局样式与css module的局部样式和谐共存。具体配置如下<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">        test: &#x2F;\.jsx?$&#x2F;,</span><br><span class="line">        loader: &#39;babel&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        test: &#x2F;\.scss$&#x2F;</span><br><span class="line">        exclude: path.resolve(__dirname, &#39;src&#x2F;views&#39;),</span><br><span class="line">        loader: &#39;style!css?modules&amp;localIndentName&#x3D;[name]__[local]!sass?sourceMap&#x3D;true&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        test: &#x2F;\.scss$&#x2F;</span><br><span class="line">        exclude: path.resolve(__dirname, &#39;src&#x2F;styles&#39;),</span><br><span class="line">        loader: &#39;style!css!sass?sourceMap&#x3D;true&#39;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* src&#x2F;app.js *&#x2F;</span><br><span class="line">import &#39;.&#x2F;styles&#x2F;app&#x2F;scss&#39;; &#x2F;&#x2F; 全局样式</span><br><span class="line">import component from &#39;.&#x2F;views&#x2F;component&#39;;</span><br><span class="line">&#x2F;* src&#x2F;views&#x2F;component.js *&#x2F;</span><br><span class="line">import &#39;.&#x2F;component.scss&#39;;</span><br></pre></td></tr></table></figure></div>
<h4 id="3-CSS-module结合react的实践"><a href="#3-CSS-module结合react的实践" class="headerlink" title="3. CSS module结合react的实践"></a>3. CSS module结合react的实践</h4></li>
</ul>
<hr>
<ul>
<li>react里面写样式我们已经熟知了，所以不再重复赘述，但是如果我们不想频繁的使用styles.xx的话，可以频繁的使用react-css-loader库，它可以通过高阶组件的形式避免重复输入styles.xx<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import react, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line">import classnames from &#39;classnames&#39;;</span><br><span class="line">import CSSModules from &#39;react-css-loader&#39;;</span><br><span class="line">import styles from &#39;.&#x2F;dialog.css&#39;;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class dialog extent Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const cx &#x3D; classnames(&#123;</span><br><span class="line">            confirm: !this.state.disabled,</span><br><span class="line">            discomfirm: this.state.disabled</span><br><span class="line">        &#125;);</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className&#x3D;&#39;root&#39;&gt;</span><br><span class="line">                &lt;a styleName&#x3D;&#123;cx&#125;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">                ...</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default CSSModule(dialog, styles);</span><br></pre></td></tr></table></figure></div></li>
<li>对比我们最初写的CSS module，它有自己的优点：<ol>
<li>不用再关注是否使用驼峰命名</li>
<li>不用每一次使用css module的时候都都关联style对象</li>
<li>可以强迫使用单一的css module</li>
<li>当stylename关联了一个undefined css module的时候，会得到一个警告</li>
<li>可以解决通过:global去写全局样式的情况，使用react-css-module可以写成这种形式：<code>&lt;div className=&quot;global-css&quot;&gt;&lt;/div&gt;</code></li>
</ol>
</li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-hello-world" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/01/hello-world/">使用hexo+github创建博客</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2020/04/01/hello-world/" class="article-date">
  <time datetime="2020-04-01T13:12:51.214Z" itemprop="datePublished">2020-04-01</time>
</a>
    
    
  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><ul>
<li>参考<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">这篇文章</a>搭建的网站，作者很优秀，可以参考参考~</li>
</ul>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-CSS3动画效果" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/04/CSS3%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/">CSS3动画效果</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/04/CSS3%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/" class="article-date">
  <time datetime="2017-12-03T16:32:23.000Z" itemprop="datePublished">2017-12-04</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html-CSS/" rel="tag">html+CSS</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <h3 id="1-2D变换"><a href="#1-2D变换" class="headerlink" title="1. 2D变换"></a><strong>1. 2D变换</strong></h3><p><strong>Transform(变形)</strong><br><code>rotate()</code>旋转函数 取值度数    <code>transform: rotate(30deg);</code><br><code>skew()</code> 倾斜函数 取值度数   <code>transform: skew(30deg);</code><br><code>scale()</code>缩放函数 取值 正数、负数和小数<br><code>transform: scaleX(1.2) scaleY(1.2);</code><br><code>translate()</code>位移函数 像素值   <code>transform: translateX(100px);</code><br><code>transform-origin()</code> 改变旋转基点   <code>transform-origin: 100px 100px;</code></p>
<h3 id="2-3D变换"><a href="#2-3D变换" class="headerlink" title="2. 3D变换"></a><strong>2. 3D变换</strong></h3><p><strong>1.transform-style（preserve-3d） 建立3D空间</strong><br><strong>2.perspective 景深</strong><br><strong>3.perspective- origin 景深基点</strong><br><strong>4.transform 新增函数</strong></p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rotateX()</span><br><span class="line">rotateY()</span><br><span class="line">rotateZ()</span><br><span class="line">translateZ()</span><br><span class="line">scaleZ()</span><br></pre></td></tr></table></figure></div>

<h3 id="3-animation"><a href="#3-animation" class="headerlink" title="3. animation"></a><strong>3. animation</strong></h3><p><strong>关键帧——keyFrames ,类似于flash</strong><br><code>animation:运动名称,运动时间,运动形式,动画延时,播放次数,播放前是否重置</code><br>只需指明两个状态，之间的过程由计算机自动计算关键帧的时间单位<br>数字：0%、25%、100%等<br>字符：from(0%)、to(100%)<br>格式</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@keyframes 动画名称</span><br><span class="line">&#123;</span><br><span class="line">	动画状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>:代码展示如下</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background-color: lightblue;</span><br><span class="line">    margin:150px auto;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes domove &#123;</span><br><span class="line">    0%&#123;width:200px;&#125;</span><br><span class="line">    33%&#123;width:300px;&#125;</span><br><span class="line">    66%&#123;width:600px;&#125;</span><br><span class="line">    100%&#123;width:1000px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">div:hover&#123;    </span><br><span class="line">        animation: domove 3s linear forwards;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="用animate做一个进度条的效果"><a href="#用animate做一个进度条的效果" class="headerlink" title="用animate做一个进度条的效果"></a><strong>用animate做一个进度条的效果</strong></h4><ul>
<li><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></div></li>
<li><h4 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#div1&#123;</span><br><span class="line">        width: 1000px;</span><br><span class="line">        height:30px;</span><br><span class="line">        border: #cccccc solid 1px;</span><br><span class="line">        margin: 200px auto;</span><br><span class="line">        border-radius: 15px;</span><br><span class="line">    &#125;</span><br><span class="line">    #div1 div&#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height:30px;</span><br><span class="line">        background-color: slategray;</span><br><span class="line">        border-radius: 15px;</span><br><span class="line">        animation: domove 4s linear forwards;</span><br><span class="line">    &#125;</span><br><span class="line">    #div1:hover div&#123;</span><br><span class="line">        animation-play-state:paused;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes domove &#123;</span><br><span class="line">        0%&#123;width:0;&#125;</span><br><span class="line">        50%&#123;width:800px;&#125;</span><br><span class="line">        100%&#123;width: 1000px;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-web标准" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/02/web%E6%A0%87%E5%87%86/">详解web标准</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2017/12/02/web%E6%A0%87%E5%87%86/" class="article-date">
  <time datetime="2017-12-02T06:48:04.000Z" itemprop="datePublished">2017-12-02</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html-CSS/" rel="tag">html+CSS</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        <ul>
<li><h4 id="WEB标准是一系列标准的集合，网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C-DOM）、ECMAScript等。"><a href="#WEB标准是一系列标准的集合，网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C-DOM）、ECMAScript等。" class="headerlink" title="WEB标准是一系列标准的集合，网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。"></a>WEB标准是一系列标准的集合，网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。</h4><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MzLmJkc3RhdGljLmNvbS83UG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzA9YmFpa2U4MCw1LDUsODAsMjYvc2lnbj0yYzBhNTMwNWYyMWZiZTA5MDg1M2NiNDYwYTA5Njc1Ni9iZDNlYjEzNTMzZmE4MjhiZjFkZmYxOTBmZDFmNDEzNDk2MGE1YWMwLmpwZw?x-oss-process=image/format,png" alt="引用块内容"></li>
</ul>
<h3 id="1-结构标准"><a href="#1-结构标准" class="headerlink" title="1.结构标准"></a><strong>1.结构标准</strong></h3><ul>
<li><p><strong>可扩展标记语言（XML）</strong></p>
<h4 id="和HTML一样，XML同样来源于标准通用标记语言，可扩展标记语言和标准通用标记语言都是能定义其他语言的语言。XML最初设计的目的是弥补HTML的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。"><a href="#和HTML一样，XML同样来源于标准通用标记语言，可扩展标记语言和标准通用标记语言都是能定义其他语言的语言。XML最初设计的目的是弥补HTML的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。" class="headerlink" title="和HTML一样，XML同样来源于标准通用标记语言，可扩展标记语言和标准通用标记语言都是能定义其他语言的语言。XML最初设计的目的是弥补HTML的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。"></a>和<a href="https://baike.baidu.com/item/HTML" target="_blank" rel="noopener">HTML</a>一样，XML同样来源于标准通用标记语言，可扩展标记语言和标准通用标记语言都是能定义其他语言的语言。XML最初设计的目的是弥补HTML的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">网络数据</a>的转换和描述。</h4></li>
<li><p><strong>可扩展超文本标记语言(<a href="https://baike.baidu.com/item/XHTML" target="_blank" rel="noopener">XTHML</a>)</strong></p>
<h4 id="目前推荐遵循的是W3C于2000年1月26日推荐XML1-0。XML虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用XML还为时过早。因此，我们在HTML4-0的基础上，用XML的规则对其进行扩展，得到了XHTML。简单的说，建立XHTML的目的就是实现HTML向XML的过渡"><a href="#目前推荐遵循的是W3C于2000年1月26日推荐XML1-0。XML虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用XML还为时过早。因此，我们在HTML4-0的基础上，用XML的规则对其进行扩展，得到了XHTML。简单的说，建立XHTML的目的就是实现HTML向XML的过渡" class="headerlink" title="目前推荐遵循的是W3C于2000年1月26日推荐XML1.0。XML虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用XML还为时过早。因此，我们在HTML4.0的基础上，用XML的规则对其进行扩展，得到了XHTML。简单的说，建立XHTML的目的就是实现HTML向XML的过渡"></a>目前推荐遵循的是W3C于2000年1月26日推荐XML1.0。XML虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用XML还为时过早。因此，我们在HTML4.0的基础上，用XML的规则对其进行扩展，得到了XHTML。简单的说，建立XHTML的目的就是实现HTML向XML的过渡</h4></li>
</ul>
<h3 id="2-表现标准"><a href="#2-表现标准" class="headerlink" title="2.表现标准"></a><strong>2.表现标准</strong></h3><ul>
<li><h4 id="层叠样式表（CSS）。目前推荐遵循的是万维网联盟（W3C）于1998年5月12日推荐CSS2。W3C创建CSS标准的目的是以CSS取代HTML表格式布局、帧和其他表现的语言。纯CSS布局与结构式XHTML相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。"><a href="#层叠样式表（CSS）。目前推荐遵循的是万维网联盟（W3C）于1998年5月12日推荐CSS2。W3C创建CSS标准的目的是以CSS取代HTML表格式布局、帧和其他表现的语言。纯CSS布局与结构式XHTML相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。" class="headerlink" title="层叠样式表（CSS）。目前推荐遵循的是万维网联盟（W3C）于1998年5月12日推荐CSS2。W3C创建CSS标准的目的是以CSS取代HTML表格式布局、帧和其他表现的语言。纯CSS布局与结构式XHTML相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。"></a><a href="https://baike.baidu.com/item/CSS/5457?fromtitle=%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8&fromid=524980" target="_blank" rel="noopener">层叠样式表</a>（CSS）。目前推荐遵循的是万维网联盟（W3C）于1998年5月12日推荐CSS2。W3C创建CSS标准的目的是以CSS取代HTML表格式布局、帧和其他表现的语言。纯CSS布局与结构式XHTML相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。</h4></li>
</ul>
<h3 id="3-行为标准"><a href="#3-行为标准" class="headerlink" title="3.行为标准"></a><strong>3.行为标准</strong></h3><ul>
<li><h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h4></li>
</ul>
<ul>
<li><h4 id="ECMAScript-是-ECMA-制定的标准脚本语言-javaScript-目前遵循的是ECMAScript-262"><a href="#ECMAScript-是-ECMA-制定的标准脚本语言-javaScript-目前遵循的是ECMAScript-262" class="headerlink" title="ECMAScript 是 ECMA 制定的标准脚本语言(javaScript),目前遵循的是ECMAScript 262"></a>ECMAScript 是 ECMA 制定的标准<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">脚本语言</a>(javaScript),目前遵循的是ECMAScript 262</h4></li>
</ul>
<ul>
<li><h4 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h4></li>
</ul>
<ul>
<li><h4 id="文档对象模型（DOM）。根据W3C-DOM规范，DOM是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM解决了Netscaped的Javascript和Microsoft的Javascript之间的冲突，给予web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。"><a href="#文档对象模型（DOM）。根据W3C-DOM规范，DOM是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM解决了Netscaped的Javascript和Microsoft的Javascript之间的冲突，给予web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。" class="headerlink" title="文档对象模型（DOM）。根据W3C DOM规范，DOM是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM解决了Netscaped的Javascript和Microsoft的Javascript之间的冲突，给予web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。"></a><a href="https://baike.baidu.com/item/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">文档对象模型</a>（DOM）。根据<a href="http://www.w3.org/DOM/" target="_blank" rel="noopener">W3C DOM规范</a>，DOM是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM解决了Netscaped的Javascript和Microsoft的Javascript之间的冲突，给予web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。</h4></li>
</ul>
<h3 id="4-代码标准"><a href="#4-代码标准" class="headerlink" title="4.代码标准"></a><strong>4.代码标准</strong></h3><ul>
<li><h4 id="必须结束标记"><a href="#必须结束标记" class="headerlink" title="必须结束标记"></a>必须结束标记</h4><h4 id="XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个”-“来关闭它。"><a href="#XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个”-“来关闭它。" class="headerlink" title="XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个”/“来关闭它。"></a>XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个”/“来关闭它。</h4><h4 id="例如-lt-br-gt"><a href="#例如-lt-br-gt" class="headerlink" title="例如:&lt;br /&gt;"></a>例如:<code>&lt;br /&gt;</code></h4><h4 id="例如：-lt-img-height-quot-80-quot-alt-quot-网页设计师-quot-src-quot-images-logo-w3cn-200x80-gif-quot-width-quot-200-quot-gt"><a href="#例如：-lt-img-height-quot-80-quot-alt-quot-网页设计师-quot-src-quot-images-logo-w3cn-200x80-gif-quot-width-quot-200-quot-gt" class="headerlink" title="例如：&lt;img height=&quot;80&quot; alt=&quot;网页设计师&quot; src=&quot;../images/logo_w3cn_200x80.gif&quot; width=&quot;200&quot; /&gt;"></a>例如：<code>&lt;img height=&quot;80&quot; alt=&quot;网页设计师&quot; src=&quot;../images/logo_w3cn_200x80.gif&quot; width=&quot;200&quot; /&gt;</code></h4></li>
<li><h4 id="小写元素和属性名"><a href="#小写元素和属性名" class="headerlink" title="小写元素和属性名"></a>小写元素和属性名</h4><h4 id="XHTML对大小写是敏感的，-lt-title-gt-和-lt-TITLE-gt-是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。"><a href="#XHTML对大小写是敏感的，-lt-title-gt-和-lt-TITLE-gt-是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。" class="headerlink" title="XHTML对大小写是敏感的，&lt;title&gt;和&lt;TITLE&gt;是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。"></a>XHTML对大小写是敏感的，<code>&lt;title&gt;</code>和<code>&lt;TITLE&gt;</code>是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。</h4><h4 id="大小写夹杂也是不被认可的，通常dreamweaver自动生成的属性名字onMouseOver也必须修改成onmouseover。"><a href="#大小写夹杂也是不被认可的，通常dreamweaver自动生成的属性名字onMouseOver也必须修改成onmouseover。" class="headerlink" title="大小写夹杂也是不被认可的，通常dreamweaver自动生成的属性名字onMouseOver也必须修改成onmouseover。"></a>大小写夹杂也是不被认可的，通常dreamweaver自动生成的属性名字<code>onMouseOver</code>也必须修改成<code>onmouseover</code>。</h4></li>
<li><h4 id="标记都必须合理嵌套"><a href="#标记都必须合理嵌套" class="headerlink" title="标记都必须合理嵌套"></a>标记都必须合理嵌套</h4><h4 id="例如：-lt-p-gt-lt-b-gt-lt-b-gt-lt-p-gt-就是说，一层一层的嵌套必须是严格对称。"><a href="#例如：-lt-p-gt-lt-b-gt-lt-b-gt-lt-p-gt-就是说，一层一层的嵌套必须是严格对称。" class="headerlink" title="例如：&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;,就是说，一层一层的嵌套必须是严格对称。"></a>例如：<code>&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;</code>,就是说，一层一层的嵌套必须是严格对称。</h4></li>
<li><h4 id="属性必须括起来"><a href="#属性必须括起来" class="headerlink" title="属性必须括起来"></a>属性必须括起来</h4><h4 id="例如-lt-height-80-gt-必须修改为：-lt-height-quot-80-quot-gt"><a href="#例如-lt-height-80-gt-必须修改为：-lt-height-quot-80-quot-gt" class="headerlink" title="例如:&lt;height=80&gt;必须修改为：&lt;height=&quot;80&quot;&gt;"></a>例如:<code>&lt;height=80&gt;</code>必须修改为：<code>&lt;height=&quot;80&quot;&gt;</code></h4><h4 id="特殊情况：你需要在属性值里使用双引号，你可以用”，单引号可以使用-amp-apos-，例如：-lt-alt-quot-say-amp-apos-hello-amp-apos-quot-gt"><a href="#特殊情况：你需要在属性值里使用双引号，你可以用”，单引号可以使用-amp-apos-，例如：-lt-alt-quot-say-amp-apos-hello-amp-apos-quot-gt" class="headerlink" title="特殊情况：你需要在属性值里使用双引号，你可以用”，单引号可以使用&amp;apos;，例如：&lt;alt=&quot;say&amp;apos;hello&amp;apos;&quot;&gt;"></a>特殊情况：你需要在属性值里使用双引号，你可以用”，单引号可以使用<code>&amp;apos;</code>，例如：<code>&lt;alt=&quot;say&amp;apos;hello&amp;apos;&quot;&gt;</code></h4></li>
<li><h4 id="特殊符号用编码表示"><a href="#特殊符号用编码表示" class="headerlink" title="特殊符号用编码表示"></a>特殊符号用编码表示</h4><h4 id="1-lt-，不是标签的一部分，都必须被编码为-amp-lt"><a href="#1-lt-，不是标签的一部分，都必须被编码为-amp-lt" class="headerlink" title="1. &lt;，不是标签的一部分，都必须被编码为&amp;lt; ;"></a>1. &lt;，不是标签的一部分，都必须被编码为<code>&amp;lt;</code> ;</h4><h4 id="2-gt-，不是标签的一部分，都必须被编码为-amp-gt"><a href="#2-gt-，不是标签的一部分，都必须被编码为-amp-gt" class="headerlink" title="2. &gt;，不是标签的一部分，都必须被编码为&amp;gt;;"></a>2. &gt;，不是标签的一部分，都必须被编码为<code>&amp;gt;</code>;</h4><h4 id="3-amp-，不是实体的一部分，都必须被编码为-amp-amp"><a href="#3-amp-，不是实体的一部分，都必须被编码为-amp-amp" class="headerlink" title="3. &amp;，不是实体的一部分，都必须被编码为&amp;amp;;"></a>3. &amp;，不是实体的一部分，都必须被编码为<code>&amp;amp;</code>;</h4><h4 id="4-不是实体的一部分，都必须被编码为-amp-nbsp"><a href="#4-不是实体的一部分，都必须被编码为-amp-nbsp" class="headerlink" title="4. ,不是实体的一部分，都必须被编码为&amp;nbsp;"></a>4. <code></code>,不是实体的一部分，都必须被编码为<code>&amp;nbsp;</code></h4></li>
<li><h4 id="给所有属性赋值"><a href="#给所有属性赋值" class="headerlink" title="给所有属性赋值"></a>给所有属性赋值</h4><h4 id="XHTML规定所有属性都必须有一个值，没有值的就重复本身。"><a href="#XHTML规定所有属性都必须有一个值，没有值的就重复本身。" class="headerlink" title="XHTML规定所有属性都必须有一个值，没有值的就重复本身。"></a>XHTML规定所有属性都必须有一个值，没有值的就重复本身。</h4><h4 id="例如：-lt-td-nowrap-gt-lt-input-type-quot-checkbox-quot-name-quot-shirt-quot-value-quot-medium-quot-checked-gt"><a href="#例如：-lt-td-nowrap-gt-lt-input-type-quot-checkbox-quot-name-quot-shirt-quot-value-quot-medium-quot-checked-gt" class="headerlink" title="例如：&lt;td nowrap&gt; &lt;input type=&quot;checkbox&quot; name=&quot;shirt&quot; value=&quot;medium&quot;checked&gt;"></a>例如：<code>&lt;td nowrap&gt; &lt;input type=&quot;checkbox&quot; name=&quot;shirt&quot; value=&quot;medium&quot;checked&gt;</code></h4><h4 id="必须修改为：-lt-td-nowrap-quot-nowrap-quot-gt-lt-input-type-quot-checkbox-quot-name-quot-shirt-quot-value-quot-medium-quot-checked-quot-checked-quot-gt"><a href="#必须修改为：-lt-td-nowrap-quot-nowrap-quot-gt-lt-input-type-quot-checkbox-quot-name-quot-shirt-quot-value-quot-medium-quot-checked-quot-checked-quot-gt" class="headerlink" title="必须修改为：&lt;td nowrap=&quot;nowrap&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;shirt&quot;value=&quot;medium&quot; checked=&quot;checked&quot;&gt;"></a>必须修改为：<code>&lt;td nowrap=&quot;nowrap&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;shirt&quot;value=&quot;medium&quot; checked=&quot;checked&quot;&gt;</code></h4></li>
<li><h4 id="在注释中不使用的符号"><a href="#在注释中不使用的符号" class="headerlink" title="在注释中不使用的符号"></a>在注释中不使用的符号</h4><h4 id="“–”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。例如下面的代码是无效的-lt-这里是注释-这里是注释-gt"><a href="#“–”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。例如下面的代码是无效的-lt-这里是注释-这里是注释-gt" class="headerlink" title="“–”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。例如下面的代码是无效的:&lt;!--这里是注释-----------这里是注释--&gt;"></a>“–”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。例如下面的代码是无效的:<code>&lt;!--这里是注释-----------这里是注释--&gt;</code></h4></li>
</ul>
<h3 id="5-测试标准"><a href="#5-测试标准" class="headerlink" title="5.测试标准"></a><strong>5.测试标准</strong></h3><h4 id="（1）标准测试的内容"><a href="#（1）标准测试的内容" class="headerlink" title="（1）标准测试的内容"></a><strong>（1）标准测试的内容</strong></h4><pre><code>#### **1. 页面校验**
#### **2.CSS文档校验**
#### **3.XHTML 1.0 标准**
#### **4.W3C标准测试**
#### **测试时一定要有文件类别宣告还有指定文件编码，才能顺利进行测试动作，开始打造一个标准的网站！**
#### `&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;`</code></pre><h4 id="（2）W3C标准测试使用说明"><a href="#（2）W3C标准测试使用说明" class="headerlink" title="（2）W3C标准测试使用说明"></a><strong>（2）W3C标准测试使用说明</strong></h4><ul>
<li><h4 id="XHTML-1-0文件类别宣告的正确写法-不可小写"><a href="#XHTML-1-0文件类别宣告的正确写法-不可小写" class="headerlink" title="XHTML 1.0文件类别宣告的正确写法 (不可小写)"></a>XHTML 1.0文件类别宣告的正确写法 (不可小写)</h4><h4 id="过度标准（Transitional）公共标识符称为-”-W3C-DTD-XHTML1-0Transitional-EN”。"><a href="#过度标准（Transitional）公共标识符称为-”-W3C-DTD-XHTML1-0Transitional-EN”。" class="headerlink" title="过度标准（Transitional）公共标识符称为:”-//W3C//DTD XHTML1.0Transitional//EN”。"></a>过度标准（Transitional）公共标识符称为:”-//W3C//DTD XHTML1.0Transitional//EN”。</h4><p>  <code>&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&gt;</code></p>
<h4 id="框架标准（Frameset）公共标识符称为：“-W3C-DTD-XHTML-1-0-Frameset-EN”。"><a href="#框架标准（Frameset）公共标识符称为：“-W3C-DTD-XHTML-1-0-Frameset-EN”。" class="headerlink" title="框架标准（Frameset）公共标识符称为：“-//W3C//DTD XHTML 1.0 Frameset//EN”。"></a>框架标准（Frameset）公共标识符称为：“-//W3C//DTD XHTML 1.0 Frameset//EN”。</h4><p>  <code>&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;&gt;</code></p>
<h4 id="严格标准（Strict）-公共标识符称为：“-W3C-DTD-XHTML-1-0-Strict-EN”。"><a href="#严格标准（Strict）-公共标识符称为：“-W3C-DTD-XHTML-1-0-Strict-EN”。" class="headerlink" title="严格标准（Strict） 公共标识符称为：“-//W3C//DTD XHTML 1.0 Strict//EN”。"></a>严格标准（Strict） 公共标识符称为：“-//W3C//DTD XHTML 1.0 Strict//EN”。</h4><p>  <code>&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&gt;</code></p>
</li>
<li><h4 id="所有网页头文件都必须改为标准格式"><a href="#所有网页头文件都必须改为标准格式" class="headerlink" title="所有网页头文件都必须改为标准格式"></a>所有网页头文件都必须改为标准格式</h4><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta</span><br><span class="line">       http-equiv&#x3D;&quot;content-type&quot;</span><br><span class="line">       content&#x3D;&quot;text&#x2F;html; charset&#x3D;gb2312&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;content-language&quot; content&#x3D;&quot;zh-cn&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;...&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">&lt;title&gt;...&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><h4 id="不允许使用target-quot-blank-quot"><a href="#不允许使用target-quot-blank-quot" class="headerlink" title="不允许使用target=&quot;_blank&quot;;"></a>不允许使用<code>target=&quot;_blank&quot;;</code></h4><p>  在HTML4.01可以使用<code>target=&quot;_blank&quot;</code>,但XHTML1.0是不被允许的.</p>
</li>
</ul>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function 外部链接()		&#x2F;&#x2F;unicode javascript</span><br><span class="line">&#123;</span><br><span class="line">      if (!document.getElementsByTagName) return;</span><br><span class="line">      var anchors &#x3D; document.getElementsByTagName(&quot;a&quot;);</span><br><span class="line">      for (var i&#x3D;0; i&lt;anchors.length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">            var anchor &#x3D; anchors;</span><br><span class="line">            if (anchor.getAttribute(&quot;href&quot;) &amp;&amp;</span><br><span class="line">            anchor.getAttribute(&quot;rel&quot;) &#x3D;&#x3D; &quot;external&quot;)</span><br><span class="line">            anchor.target &#x3D; &quot;_blank&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br><span class="line">window.onload &#x3D; 外部链接;</span><br></pre></td></tr></table></figure></div>
<pre><code>#### 你可以把它保存成一个.js文件(比如外部链接.js)，然后通过外部联接方法调用：</code></pre><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;外部链接.js&quot;&gt;&lt;/script&gt;</code></p>
<ul>
<li><h4 id="XHTML-1-0要求所有的标签必须关闭"><a href="#XHTML-1-0要求所有的标签必须关闭" class="headerlink" title="XHTML 1.0要求所有的标签必须关闭"></a>XHTML 1.0要求所有的标签必须关闭</h4><h4 id="所有没有成对的空标签必须以-gt-结尾-例如："><a href="#所有没有成对的空标签必须以-gt-结尾-例如：" class="headerlink" title="所有没有成对的空标签必须以 /&gt;结尾,例如："></a>所有没有成对的空标签必须以 /&gt;结尾,例如：</h4><p>  <code>&lt;hr /&gt;</code><br>  <code>&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;</code></p>
</li>
<li><h4 id="所有标签元素名都使用小写"><a href="#所有标签元素名都使用小写" class="headerlink" title="所有标签元素名都使用小写"></a>所有标签元素名都使用小写</h4><h4 id="错误-lt-HTML-gt-lt-TITLE-gt-lt-HEAD-gt-lt-BODY-gt"><a href="#错误-lt-HTML-gt-lt-TITLE-gt-lt-HEAD-gt-lt-BODY-gt" class="headerlink" title="错误 &lt;HTML&gt; &lt;TITLE&gt; &lt;HEAD&gt; &lt;BODY&gt;"></a>错误 <code>&lt;HTML&gt; &lt;TITLE&gt; &lt;HEAD&gt; &lt;BODY&gt;</code></h4><h4 id="正确-lt-html-gt-lt-title-gt-lt-head-gt-lt-body-gt"><a href="#正确-lt-html-gt-lt-title-gt-lt-head-gt-lt-body-gt" class="headerlink" title="正确&lt;html&gt; &lt;title&gt; &lt;head&gt; &lt;body&gt;"></a>正确<code>&lt;html&gt; &lt;title&gt; &lt;head&gt; &lt;body&gt;</code></h4></li>
<li><h4 id="同一个id选择器不可同时使用"><a href="#同一个id选择器不可同时使用" class="headerlink" title="同一个id选择器不可同时使用"></a>同一个id选择器不可同时使用</h4><h4 id="一个网页中id-”xx”同一个选择器不能重复使用-若需要重复请用class-”xx”"><a href="#一个网页中id-”xx”同一个选择器不能重复使用-若需要重复请用class-”xx”" class="headerlink" title="一个网页中id=”xx”同一个选择器不能重复使用,若需要重复请用class=”xx”"></a>一个网页中id=”xx”同一个选择器不能重复使用,若需要重复请用class=”xx”</h4></li>
<li><h4 id="标签必须是一对"><a href="#标签必须是一对" class="headerlink" title="标签必须是一对"></a>标签必须是一对</h4><p>  例如：<code>&lt;p&gt;&lt;/p&gt;</code></p>
</li>
<li><h4 id="正确标签顺序"><a href="#正确标签顺序" class="headerlink" title="正确标签顺序"></a>正确标签顺序</h4></li>
<li><h4 id="JavaScript写法"><a href="#JavaScript写法" class="headerlink" title="JavaScript写法"></a>JavaScript写法</h4><h4 id="W3C标准必须为程式指定类型type-text-javascript-所以要写为"><a href="#W3C标准必须为程式指定类型type-text-javascript-所以要写为" class="headerlink" title="W3C标准必须为程式指定类型type=text/javascript,所以要写为"></a>W3C标准必须为程式指定类型type=text/javascript,所以要写为</h4><h4 id="lt-scripttype-quot-text-javascript-quot-gt-或者"><a href="#lt-scripttype-quot-text-javascript-quot-gt-或者" class="headerlink" title="&lt;scripttype=&quot;text/javascript&quot;&gt;或者"></a><code>&lt;scripttype=&quot;text/javascript&quot;&gt;</code>或者</h4><h4 id="lt-script-language-quot-javascript-quot-type-quot-text-javascript-quot-gt"><a href="#lt-script-language-quot-javascript-quot-type-quot-text-javascript-quot-gt" class="headerlink" title="&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;"></a><code>&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</code></h4><h4 id="载入外部-js独立档案的写法"><a href="#载入外部-js独立档案的写法" class="headerlink" title="载入外部.js独立档案的写法"></a>载入外部.js独立档案的写法</h4><p>  <code>&lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><h4 id="绝对不可省略单引号或者双引号"><a href="#绝对不可省略单引号或者双引号" class="headerlink" title="绝对不可省略单引号或者双引号"></a>绝对不可省略单引号或者双引号</h4><h4 id="错误-lt-img-src-bg-gif-width-140-height-30-alt-text-gt"><a href="#错误-lt-img-src-bg-gif-width-140-height-30-alt-text-gt" class="headerlink" title="错误: &lt;img src=bg.gif width=140 height=30 alt=text /&gt;"></a>错误: <code>&lt;img src=bg.gif width=140 height=30 alt=text /&gt;</code></h4><h4 id="正确-lt-img-src-quot-bg-gif-quot-width-quot-140-quot-height-quot-30-quot-alt-quot-text-quot-gt"><a href="#正确-lt-img-src-quot-bg-gif-quot-width-quot-140-quot-height-quot-30-quot-alt-quot-text-quot-gt" class="headerlink" title="正确:&lt;img src=&quot;bg.gif&quot; width=&quot;140&quot; height=&quot;30&quot; alt=&quot;text&quot; /&gt;"></a>正确:<code>&lt;img src=&quot;bg.gif&quot; width=&quot;140&quot; height=&quot;30&quot; alt=&quot;text&quot; /&gt;</code></h4></li>
<li><h4 id="图片标签加上文字说明alt-quot-文字说明-quot"><a href="#图片标签加上文字说明alt-quot-文字说明-quot" class="headerlink" title="图片标签加上文字说明alt=&quot;文字说明&quot;"></a>图片标签加上文字说明<code>alt=&quot;文字说明&quot;</code></h4><p>  <code>&lt;img src=&quot;bg.gif&quot; height=&quot;50&quot; border=&quot;0&quot; alt=&quot;说明文字&quot; /&gt;</code></p>
</li>
<li><h4 id="背景音乐不允许使用-bgsound标签"><a href="#背景音乐不允许使用-bgsound标签" class="headerlink" title="背景音乐不允许使用 bgsound标签"></a>背景音乐不允许使用 <code>bgsound</code>标签</h4><p>  正确写法如下，然后通过外部链接方法调用</p>
  <div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	var MSIE&#x3D;navigator.userAgent.indexOf(&quot;MSIE&quot;);</span><br><span class="line">	var NETS&#x3D;navigator.userAgent.indexOf(&quot;Netscape&quot;);</span><br><span class="line">	var OPER&#x3D;navigator.userAgent.indexOf(&quot;Opera&quot;);</span><br><span class="line">	if((MSIE&gt;-1) || (OPER&gt;-1)) &#123;</span><br><span class="line">	document.write(&quot;&lt;BGSOUND SRC&#x3D;背景音乐地址 LOOP&#x3D;INFINITE&gt;&quot;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	document.write(&quot;&lt;EMBED SRC&#x3D;背景音乐地址 AUTOSTART&#x3D;TRUE &quot;);</span><br><span class="line">	document.write(&quot;HIDDEN&#x3D;true VOLUME&#x3D;100 LOOP&#x3D;TRUE&gt;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#96;&#96;&#96;	</span><br><span class="line"></span><br><span class="line">* #### 不允许使用框架标签</span><br><span class="line">    #### 用js通过外链引入页面</span><br></pre></td></tr></table></figure></div>
<p>  function ifr(url,w,h){</p>
<pre><code>document.write(&apos;&lt;iframe id=&quot;ifr&quot; name=&quot;ifr&quot; width=&quot;&apos;+w+&apos;&quot; height=&quot;&apos;+h+&apos;&quot; border=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;&apos;+url+&apos;&quot;&gt;&lt;/iframe&gt;&apos;);}</code></pre><pre><code></code></pre></li>
<li><h4 id="注解文字不可包含”–”符号"><a href="#注解文字不可包含”–”符号" class="headerlink" title="注解文字不可包含”–”符号"></a>注解文字不可包含”–”符号</h4><h4 id="错误-lt-OEC-SPACE-gt"><a href="#错误-lt-OEC-SPACE-gt" class="headerlink" title="错误&lt;!-- OEC--SPACE --&gt;"></a>错误<code>&lt;!-- OEC--SPACE --&gt;</code></h4><h4 id="正确-lt-OECSPACE-gt"><a href="#正确-lt-OECSPACE-gt" class="headerlink" title="正确 &lt;!-- OECSPACE --&gt;"></a>正确 <code>&lt;!-- OECSPACE --&gt;</code></h4></li>
<li><h4 id="正确使用CSS样式表"><a href="#正确使用CSS样式表" class="headerlink" title="正确使用CSS样式表"></a>正确使用<a href="https://baike.baidu.com/item/CSS/5457?fromtitle=CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8&fromid=224735" target="_blank" rel="noopener">CSS样式表</a></h4></li>
<li><h4 id="非标签部分以编码表示"><a href="#非标签部分以编码表示" class="headerlink" title="非标签部分以编码表示"></a>非标签部分以编码表示</h4></li>
<li><h4 id="所有属性都必须有值"><a href="#所有属性都必须有值" class="headerlink" title="所有属性都必须有值"></a>所有属性都必须有值</h4></li>
</ul>
<h3 id="6-优点"><a href="#6-优点" class="headerlink" title="6.优点"></a><strong>6.优点</strong></h3><h3 id="1-对于访问者"><a href="#1-对于访问者" class="headerlink" title="(1)对于访问者"></a><em>(1)对于访问者</em></h3><pre><code>**文件下载与页面显示速度更快。**
**内容能被更多的用户所访问（包括失明、视弱、色盲等残障人士）。**
**内容能被更广泛的设备所访问(包括屏幕阅读机,手持设备,搜索机器人,打印机,电冰箱等)。**
**用户能够通过样式选择定制自己的表现界面。**
**所有页面都能提供适于打印的版本。**</code></pre><h3 id="2-对于网站所有者"><a href="#2-对于网站所有者" class="headerlink" title="(2)对于网站所有者"></a><em>(2)对于网站所有者</em></h3><pre><code>**更少的代码和组件，容易维护。**
**带宽要求降低（代码更简洁），成本降低。举个例子：当 ESPN.com 使用 CSS改版后，每天节约超过两兆字节（terabytes）的带宽。**
**更容易被搜寻引擎搜索到。**
**改版方便，不需要变动页面内容。**
**提供打印版本而不需要复制内容。**
**提高网站易用性。在美国，有严格的法律条款（Section 508）来约束政府网站必须达到一定的易用性，其他国家也有类似的要求。**</code></pre><h3 id="7-误区"><a href="#7-误区" class="headerlink" title="7.误区"></a><strong>7.误区</strong></h3><pre><code>**不为通过校验才标准化**
    web标准的本意是实现内容(结构)和表现分离，就是将样式剥离出来放在单独的css文件中。这样做的好处是可以分别处理内容和表现，也方便搜索和内容的再利用。
    W3C校验仅仅是帮助你检查XHTML代码的书写是否规范，css的属性是否都在CCS2的规范内。代码的标准化仅仅是第一步，不是说通过的校验，我的网页就标准化了。我们不是为了虚名，或者向别人炫耀：“看我的页面通过了校验”而去标准化，我们的目的是为了使自己的网页设计工作更有效率，为了缩小网页尺寸，为了能够在任何浏览器和网络设备中正常浏览。

**不用传统表格思维来套div**

**不必每块内容都建id**
    我们知道内容都是有结构的(如果不明白，请[点击阅读](http://www.w3cn.org/article/tips/2004/43),理解表现和结构相分离 ,相同的结构的内容我们可以用同一个样式来定义，比如相同级别的标题、正文、图片。对于多次引用的样式可以用class来定义，不需要每个都用id；另外也不是说一定要用，你完全可以用别的来代替，同样都是块级元素，一样有盒模型的七个参数，仅仅方便浮动。</code></pre>
      
    </div>
    
  </div>
  
  
</article>

  



</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/default-avatar.jpeg" title="图片来自网络"></img>
    <h3 class="avatar-name">
      
        少年梦江南
      
    </h3>
    <p class="avatar-slogan">
      前端菜鸟攻城狮，请多多指教
    </p>
  </div>
</div>


  
    

  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-CSS/" rel="tag">html+CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react%E7%9B%B8%E5%85%B3/" rel="tag">react相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%94%9FJS/" rel="tag">原生JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%81%87%E5%88%B0%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/" rel="tag">遇到的实际问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/html-CSS/" style="font-size: 15px;">html+CSS</a> <a href="/tags/react%E7%9B%B8%E5%85%B3/" style="font-size: 20px;">react相关</a> <a href="/tags/%E5%8E%9F%E7%94%9FJS/" style="font-size: 10px;">原生JS</a> <a href="/tags/%E9%81%87%E5%88%B0%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/" style="font-size: 10px;">遇到的实际问题</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/19/%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E8%B6%85%E9%93%BE/">处理文本中的超链</a>
          </li>
        
          <li>
            <a href="/2020/04/19/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">react生命周期</a>
          </li>
        
          <li>
            <a href="/2020/04/10/virtualDOM/">react virtual DOM</a>
          </li>
        
          <li>
            <a href="/2020/04/03/hocRenderHook/">对比分析HOC,render props,react hook</a>
          </li>
        
          <li>
            <a href="/2020/04/02/jsArray/">原生JS实现常见高阶数组方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <a style="display: block;" href="https://luoyimaid.github.io/" title target='_blank'
        >少年梦江南</a>
      
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width">
    &copy; 2020 少年梦江南 &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">少年告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>